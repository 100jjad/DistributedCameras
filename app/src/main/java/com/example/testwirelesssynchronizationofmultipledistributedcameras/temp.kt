package com.example.testwirelesssynchronizationofmultipledistributedcameras

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.graphics.*
import android.graphics.Matrix.ScaleToFit
import android.hardware.camera2.*
import android.media.MediaRecorder
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import android.util.Range
import android.util.Size
import android.util.SparseIntArray
import android.view.Surface
import android.view.TextureView
import android.widget.Toast
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.*
import java.util.Collections.singletonList
import kotlin.Comparator


class Camera3(private val activity: Activity, private val textureView: AutoFitTextureView) {

    private var onBitmapReady: (Bitmap) -> Unit = {}
    private val cameraManager: CameraManager =
        textureView.context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
    private var cameraFacing = CameraCharacteristics.LENS_FACING_BACK
    private var previewSize: Size? = null
    //Current Camera id
    private var cameraId = "-1"
    private var backgroundHandler: Handler? = null
    private var backgroundThread: HandlerThread? = null
    private var cameraDevice: CameraDevice? = null
    //
    private var cameraCaptureSession: CameraCaptureSession? = null
    // capture request builder for camera.
    private var captureRequestBuilder: CaptureRequest.Builder? = null
    // capture request generated by above builder.
    private var captureRequest: CaptureRequest? = null
    private var flash = FLASH.OFF
    private var cameraState = STATE_PREVIEW

    private var exposureCompensationRange: Range<Int>? = null
    private var mediaRecorder: MediaRecorder? = null
    private var isRecordingVideo: Boolean = false


    private var surface: Surface? = null

    private var isFlashSupported = true

    private var mSensorOrientation = 0
    private val cameraCaptureCallBack = object : CameraCaptureSession.CaptureCallback() {

        private fun process(captureResult: CaptureResult) {
            when (cameraState) {
// We have nothing to do when the camera preview is working normally.
                STATE_PREVIEW -> {
                }
                STATE_WAITING_LOCK -> {
                    val afState = captureResult[CaptureResult.CONTROL_AF_STATE]
                    if (afState == null) {
                        captureStillPicture()
                    } else if (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED || afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED) {
// CONTROL_AE_STATE can be null on some devices
                        val aeState = captureResult[CaptureResult.CONTROL_AE_STATE]
                        if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {
                            cameraState = STATE_PICTURE_TAKEN
                            captureStillPicture()
                        } else runPrecaptureSequence()
                    }
                }
                STATE_WAITING_PRECAPTURE -> {
// CONTROL_AE_STATE can be null on some devices
                    val aeState = captureResult[CaptureResult.CONTROL_AE_STATE]
                    if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE || aeState == CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED) {
                        cameraState = STATE_WAITING_NON_PRECAPTURE
                    }
                }
                STATE_WAITING_NON_PRECAPTURE -> {
// CONTROL_AE_STATE can be null on some devices
                    val aeState = captureResult[CaptureResult.CONTROL_AE_STATE]
                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {
                        cameraState = STATE_PICTURE_TAKEN
                        captureStillPicture()
                    }
                }
            }
        }

        override fun onCaptureProgressed(
            session: CameraCaptureSession,
            request: CaptureRequest,
            partialResult: CaptureResult
        ) {
            process(partialResult)
        }

        override fun onCaptureCompleted(
            session: CameraCaptureSession,
            request: CaptureRequest,
            result: TotalCaptureResult
        ) {
            process(result)
        }
    }


    internal companion object {
// These values represent Camera states.

        // Showing Camera Preview.
        private const val STATE_PREVIEW = 0
        // Waiting for the focus to be locked.
        private const val STATE_WAITING_LOCK = 1
        // Waiting for the exposure to be in pre-capture state.
        private const val STATE_WAITING_PRECAPTURE = 2
        // Waiting for the exposure to be in any other state except pre-capture state.
        private const val STATE_WAITING_NON_PRECAPTURE = 3
        // Picture was taken
        private const val STATE_PICTURE_TAKEN = 4

        internal const val REQUEST_CAMERA_PERMISSION = 1001

        private val ORIENTATIONS = SparseIntArray()

        init {
            ORIENTATIONS.append(Surface.ROTATION_0, 90)
            ORIENTATIONS.append(Surface.ROTATION_90, 0)
            ORIENTATIONS.append(Surface.ROTATION_180, 270)
            ORIENTATIONS.append(Surface.ROTATION_270, 180)
        }

        /**
         * Max preview width that is guaranteed by Camera2 API
         */
        private const val MAX_PREVIEW_WIDTH = 1920

        private const val MAX_PREVIEW_HEIGHT = 1080

        private fun chooseOptimalSize(
            choices: Array<Size>, textureViewWidth: Int,
            textureViewHeight: Int, maxWidth: Int, maxHeight: Int, aspectRatio: Size
        ): Size {

            // Collect the supported resolutions that are at least as big as the preview Surface
            val bigEnough = arrayListOf<Size>()
            // Collect the supported resolutions that are smaller than the preview Surface
            val notBigEnough = arrayListOf<Size>()
            val w = aspectRatio.width
            val h = aspectRatio.height
            for (option in choices) {
                if (option.width <= maxWidth && option.height <= maxHeight &&
                    option.height == option.width * h / w
                ) {
                    if (option.width >= textureViewWidth && option.height >= textureViewHeight) {
                        bigEnough.add(option)
                    } else {
                        notBigEnough.add(option)
                    }
                }
            }
            return when {
                bigEnough.isNotEmpty() -> Collections.min(bigEnough, compareSizesByArea)
                notBigEnough.isNotEmpty() -> Collections.max(notBigEnough, compareSizesByArea)
                else -> {
                    Log.e("Camera", "Couldn't find any suitable preview size")
                    choices[0]
                }
            }
        }

        private val compareSizesByArea = Comparator<Size> { lhs, rhs ->
            // We cast here to ensure the multiplications won't overflow
            java.lang.Long.signum(lhs.width.toLong() * lhs.height - rhs.width.toLong() * rhs.height)
        }

    }

    private val surfaceTextureListener = object : TextureView.SurfaceTextureListener {
        override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {
            Toast.makeText(activity , "width : $width , height : $height" , Toast.LENGTH_LONG).show()
            configureTransform(width, height)
        }

        override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {

        }

        override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {
            return true
        }

        override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {
            openCamera(width, height)

        }
    }

    private val cameraStateCallback = object : CameraDevice.StateCallback() {
        override fun onOpened(camera: CameraDevice) {
            this@Camera3.cameraDevice = camera
            createPreviewSession()
        }

        override fun onDisconnected(camera: CameraDevice) {
            camera.close()
            this@Camera3.cameraDevice = null
        }

        override fun onError(camera: CameraDevice, error: Int) {
        }
    }

    fun onResume() {
        openBackgroundThread()
        if (textureView.isAvailable) {
            openCamera(textureView.width, textureView.height)
        } else textureView.surfaceTextureListener = surfaceTextureListener
    }
    fun close() {
        closeCamera()
        closeBackgroundThread()
    }
    private fun closeCamera() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession!!.close()
            cameraCaptureSession = null
            //   cameraSessionClosed = true
        }

        if (cameraDevice != null) {
            cameraDevice!!.close()
            cameraDevice = null
        }
    }

    private fun closeBackgroundThread() {
        if (backgroundHandler != null) {
            backgroundThread!!.quitSafely()
            backgroundThread = null
            backgroundHandler = null
        }
    }

    internal fun openCamera(width: Int, height: Int) {
        if (ContextCompat.checkSelfPermission(
                textureView.context,
                Manifest.permission.CAMERA
            ) == PackageManager.PERMISSION_GRANTED
        ) {

            setUpCameraOutputs(width, height)
            configureTransform(width, height)

            cameraManager.openCamera(cameraId, cameraStateCallback, backgroundHandler)


        } else {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.CAMERA), REQUEST_CAMERA_PERMISSION)
            Log.e("Camera2", "دسترسی وجود ندارد")
        }
    }

    private fun setUpCameraOutputs(width: Int, height: Int) {
        try {
            for (cameraId in cameraManager.cameraIdList) {
                val cameraCharacteristics = cameraManager.getCameraCharacteristics(cameraId)
                val cameraFacing = cameraCharacteristics.get(CameraCharacteristics.LENS_FACING)

                if (cameraFacing == this.cameraFacing) {
                    val streamConfigurationMap = cameraCharacteristics.get(
                        CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP
                    )
                    exposureCompensationRange = cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE)

                    val largest = Collections.max(
                        streamConfigurationMap?.getOutputSizes(ImageFormat.JPEG)?.toList(),
                        compareSizesByArea
                    )
                    val displayRotation = activity.windowManager.defaultDisplay.rotation

                    //noinspection ConstantConditions
                    mSensorOrientation = cameraCharacteristics[CameraCharacteristics.SENSOR_ORIENTATION] ?: 0

                    var swappedDimensions = false

                    when (displayRotation) {
                        Surface.ROTATION_0 -> {
                        }
                        Surface.ROTATION_90 -> {
                        }
                        Surface.ROTATION_180 -> {
                            swappedDimensions = mSensorOrientation == 90 || mSensorOrientation == 270
                        }
                        Surface.ROTATION_270 -> {
                            swappedDimensions = mSensorOrientation == 0 || mSensorOrientation == 180
                        }
                        else -> Log.e("Camera2", "Display rotation is invalid: $displayRotation")

                    }

                    val displaySize = Point()

                    activity.windowManager.defaultDisplay.getSize(displaySize)

                    var rotatedPreviewWidth = width
                    var rotatedPreviewHeight = height
                    var maxPreviewWidth = displaySize.x
                    var maxPreviewHeight = displaySize.y

                    if (swappedDimensions) {
                        rotatedPreviewWidth = height
                        rotatedPreviewHeight = width
                        maxPreviewWidth = displaySize.y
                        maxPreviewHeight = displaySize.x
                    }

                    if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {
                        maxPreviewWidth = MAX_PREVIEW_WIDTH
                    }

                    if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
                        maxPreviewHeight = MAX_PREVIEW_HEIGHT
                    }

                    previewSize = chooseOptimalSize(
                        streamConfigurationMap!!.getOutputSizes(SurfaceTexture::class.java),
                        rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                        maxPreviewHeight, largest
                    )

                    // We fit the aspect ratio of TextureView to the size of preview we picked.
                    val orientation = activity.resources.configuration.orientation

                    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
                        textureView.setAspectRatio(
                            previewSize!!.width, previewSize!!.height
                        )
                    } else {
                        textureView.setAspectRatio(
                            previewSize!!.height, previewSize!!.width
                        )
                    }
                    isFlashSupported = cameraCharacteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE) ?: false
                    this.cameraId = cameraId

                    return
                }
            }
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }

    private fun configureTransform(viewWidth: Int, viewHeight: Int) {
        val rotation = activity.windowManager.defaultDisplay.rotation
        val matrix = Matrix()
        val viewRect = RectF(0f, 0f, viewWidth.toFloat(), viewHeight.toFloat())
        val bufferRect = RectF(0f, 0f, previewSize!!.height.toFloat(), previewSize!!.width.toFloat())
        val centerX = viewRect.centerX()
        val centerY = viewRect.centerY()
        if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {
            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY())
            matrix.setRectToRect(viewRect, bufferRect, ScaleToFit.FILL)
            val scale = Math.max(
                viewHeight.toFloat() / previewSize!!.height,
                viewWidth.toFloat() / previewSize!!.width
            )
            matrix.postScale(scale, scale, centerX, centerY)
            matrix.postRotate((90 * (rotation - 2)).toFloat(), centerX, centerY)
        } else if (Surface.ROTATION_180 == rotation) {
            matrix.postRotate(180f, centerX, centerY)
        }
        textureView.setTransform(matrix)
    }

    private fun getOrientation(rotation: Int) =

        (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360


    private fun openBackgroundThread() {
        backgroundThread = HandlerThread("camera_background_thread")
        backgroundThread!!.start()
        backgroundHandler = Handler(backgroundThread!!.looper)
    }

    // Creates a new camera preview session
    private fun createPreviewSession() {

        try {

            val surfaceTexture = textureView.surfaceTexture
            surfaceTexture?.setDefaultBufferSize(previewSize!!.width, previewSize!!.height)

// This is the output Surface we need to start preview.
            if (surface == null)
                surface = Surface(surfaceTexture)

            val previewSurface = surface

            captureRequestBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)
            captureRequestBuilder!!.addTarget(previewSurface!!)

            cameraDevice!!.createCaptureSession(
                singletonList(previewSurface),
                object : CameraCaptureSession.StateCallback() {

                    override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {
                        if (cameraDevice == null) {
                            return
                        }

                        try {
                            this@Camera3.cameraCaptureSession = cameraCaptureSession
                            //     cameraSessionClosed = false

                            captureRequestBuilder!!.set(
                                CaptureRequest.CONTROL_AF_MODE,
                                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                            )

                            captureRequest = captureRequestBuilder!!.build()

                            this@Camera3.cameraCaptureSession!!.setRepeatingRequest(
                                captureRequest!!,
                                cameraCaptureCallBack,
                                backgroundHandler
                            )


                            setFlashMode(captureRequestBuilder!!, true)


                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }

                    }

                    override fun onConfigureFailed(cameraCaptureSession: CameraCaptureSession) {

                    }
                }, backgroundHandler
            )
        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }

    }


    private fun flashOn(captureRequestBuilder: CaptureRequest.Builder) {
        // برای API level 28 و بالاتر
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            captureRequestBuilder.set(
                CaptureRequest.FLASH_MODE,
                CaptureRequest.FLASH_MODE_TORCH
            )
        } else {
            // برای API level های پایین‌تر
            captureRequestBuilder.set(
                CaptureRequest.CONTROL_AE_MODE,
                CaptureRequest.CONTROL_AE_MODE_ON_ALWAYS_FLASH
            )
            captureRequestBuilder.set(
                CaptureRequest.FLASH_MODE,
                CaptureRequest.FLASH_MODE_TORCH
            )
        }
    }

    // sets flash mode for a capture request builder
    private fun setFlashMode(
        captureRequestBuilder: CaptureRequest.Builder,
        trigger: Boolean
    ) {
        if (trigger) {
            // This is how to tell the camera to trigger.
            captureRequestBuilder.set(
                CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,
                CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START
            )
        }
        when (flash) {
            FLASH.ON -> flashOn(captureRequestBuilder)
            FLASH.AUTO -> {
                captureRequestBuilder.set(
                    CaptureRequest.CONTROL_AE_MODE,
                    CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH
                )
            }
            else -> captureRequestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF)
        }
    }

    enum class FLASH {
        ON, OFF, AUTO
    }

    // Locks the preview focus.
    private fun lockPreview() {
        try {

            captureRequestBuilder!!.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_START)
// Tell #cameraCaptureCallback to wait for the lock.
            cameraState = STATE_WAITING_LOCK
            cameraCaptureSession!!.capture(
                captureRequestBuilder!!.build(), cameraCaptureCallBack, backgroundHandler
            )
        } catch (e: Exception) {
            e.printStackTrace()
        }

    }


    private fun unlockPreview() {
        try {
// Reset the auto-focus trigger
            captureRequestBuilder!!.set(CaptureRequest.CONTROL_AF_TRIGGER, CameraMetadata.CONTROL_AF_TRIGGER_CANCEL)

            setFlashMode(captureRequestBuilder!!, false)


            cameraCaptureSession!!.capture(
                captureRequestBuilder!!.build(), cameraCaptureCallBack, backgroundHandler
            )
// After this, the camera will go back to the normal state of preview.
            cameraState = STATE_PREVIEW



            cameraCaptureSession!!.setRepeatingRequest(
                captureRequest!!, cameraCaptureCallBack,
                backgroundHandler
            )


        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }

    }



    /**
     * Run the precapture sequence for capturing a still image. This method should be called when
     * we get a response in {@link #mCaptureCallback} from {@link #lockPreview()}.
     */

    private fun runPrecaptureSequence() {
        try {


// Tell #cameraCaptureCallback to wait for the precapture sequence to be set.
            cameraState = STATE_WAITING_PRECAPTURE

            setFlashMode(captureRequestBuilder!!, true)

            cameraCaptureSession!!.capture(captureRequestBuilder!!.build(), cameraCaptureCallBack, backgroundHandler)


        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }


    }


    private fun captureBitmap() {
        if (textureView.isAvailable) {
            textureView.bitmap?.let { bitmap ->
                onBitmapReady(bitmap) // Only if the bitmap is not null
            }
        }
    }

    /**
     * Capture a still picture. This method should be called when we get a response in
     * {@link #cameraCaptureCallback} from both {@link #lockPreview()}.
     */
    private fun captureStillPicture() {
        try {
// This is the CaptureRequest.Builder that we use to take a picture.
            val captureBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE)

//            val surfaceTexture = textureView.surfaceTexture
//            surfaceTexture.setDefaultBufferSize(previewSize!!.width, previewSize!!.height)
            captureBuilder.addTarget(surface!!)
            // Use the same AE and AF modes as the preview.
            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)


            setFlashMode(captureBuilder, true)

            // Orientation
            val rotation = activity.windowManager.defaultDisplay.rotation

            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation))

            cameraCaptureSession!!.stopRepeating()
            cameraCaptureSession!!.abortCaptures()
            cameraCaptureSession!!.capture(captureBuilder.build(), object : CameraCaptureSession.CaptureCallback() {
                override fun onCaptureCompleted(
                    session: CameraCaptureSession,
                    request: CaptureRequest,
                    result: TotalCaptureResult
                ) {

                    captureBitmap()
                    unlockPreview()


                }
            }, null)


        } catch (e: CameraAccessException) {
            e.printStackTrace()
        }
    }


    /**
     * تابع برای پیکربندی MediaRecorder
     * پارامتر outputFile مسیر فایل خروجی ضبط شده است.
     */
    private fun setUpMediaRecorder(outputFile: String , framerate : Int) {
        mediaRecorder = MediaRecorder()
        mediaRecorder?.apply {
            // تنظیم منابع صوتی و تصویری
            setAudioSource(MediaRecorder.AudioSource.MIC)
            setVideoSource(MediaRecorder.VideoSource.SURFACE)

            Log.d("Camera2", "Video will be saved at: $outputFile")

            // تنظیم فرمت خروجی
            setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
            try {
                // **اینجا مسیر فایل خروجی را تنظیم کنید**
                setOutputFile(outputFile)
                Log.d("Camera2", "MediaRecorder setup successful")
            } catch (e: Exception) {
                Log.e("Camera2", "Error in MediaRecorder setup: ${e.message}")
            }

            // تنظیمات کدگذاری ویدئو – می‌توانید این مقادیر را تغییر دهید
            setVideoEncodingBitRate(10000000)
            setVideoFrameRate(framerate)
            // اندازه ویدئو را بر اساس previewSize انتخاب می‌کنیم
            previewSize?.let {
                setVideoSize(it.width, it.height)
            } ?: run {
                // در صورت نبود اندازه مناسب، از یک مقدار پیش‌فرض استفاده کنید
                setVideoSize(1920, 1080)
            }
            setVideoEncoder(MediaRecorder.VideoEncoder.H264)
            setAudioEncoder(MediaRecorder.AudioEncoder.AAC)

            // تنظیم جهت چرخش ویدئو بر اساس جهت سنسور
            val rotation = activity.windowManager.defaultDisplay.rotation
            val orientation = getOrientation(rotation)
            setOrientationHint(orientation)

            prepare()
        }
    }

    /**
     * شروع ضبط ویدئو.
     * پارامتر outputFile مسیر ذخیره فایل ضبط شده است.
     */
    fun startRecordingVideo(outputFile: String , currentExposureValue:Int , framerate : Int) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                Log.e("Camera2", "WRITE_EXTERNAL_STORAGE permission is not granted!")
                return
            }
        }
        if (cameraDevice == null || !textureView.isAvailable || previewSize == null) return

        try {
            // ابتدا MediaRecorder را پیکربندی می‌کنیم
            setUpMediaRecorder(outputFile , framerate)

            // تنظیم سطح (Surface) مربوط به preview و MediaRecorder
            val texture = textureView.surfaceTexture
            texture?.setDefaultBufferSize(previewSize!!.width, previewSize!!.height)
            val previewSurface = Surface(texture)
            val recorderSurface = mediaRecorder!!.surface

            if (recorderSurface == null) {
                Log.e("Camera2", "Recorder Surface is NULL!")
                return
            }

            // ایجاد یک CaptureRequest جدید برای حالت ضبط (TEMPLATE_RECORD)
            captureRequestBuilder = cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_RECORD)
            captureRequestBuilder?.apply {
                set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON)
                set(CaptureRequest.CONTROL_AE_EXPOSURE_COMPENSATION, currentExposureValue)
            }
            captureRequestBuilder!!.addTarget(previewSurface)
            captureRequestBuilder!!.addTarget(recorderSurface)


            // بستن session قبلی (در صورت نیاز) و ایجاد session جدید شامل دو سطح
            cameraDevice!!.createCaptureSession(
                Arrays.asList(previewSurface, recorderSurface),
                object : CameraCaptureSession.StateCallback() {
                    override fun onConfigured(session: CameraCaptureSession) {
                        cameraCaptureSession = session
                        try {
                            captureRequest = captureRequestBuilder!!.build()
                            // آغاز ارسال درخواست‌های تکراری به دوربین
                            cameraCaptureSession!!.setRepeatingRequest(captureRequest!!, null, backgroundHandler)
                            // شروع ضبط توسط MediaRecorder
                            mediaRecorder?.start()
                            isRecordingVideo = true
                        } catch (e: CameraAccessException) {
                            e.printStackTrace()
                        }
                    }

                    override fun onConfigureFailed(session: CameraCaptureSession) {
                        // در صورت شکست، می‌توانید خطایی نمایش دهید یا session قبلی را بازیابی کنید.
                    }
                },
                backgroundHandler
            )

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }



    /**
     * توقف ضبط ویدئو.
     * پس از توقف، یک session جدید preview ایجاد می‌شود.
     */
    fun stopRecordingVideo() {
        if (!isRecordingVideo) {
            Log.e("Camera2", "MediaRecorder stop called while not recording!")
            return
        }
        else{
            try {
                isRecordingVideo = false
                // توقف ضبط
                mediaRecorder?.apply {
                    try {
                        stop()
                        reset()
                        release()
                    } catch (e: Exception) {
                        // در صورت خطا (مثلاً اگر ضبط به درستی آغاز نشده باشد)
                        e.printStackTrace()
                        Log.e("Camera2", "MediaRecorder stop called while not recording! : ${e.message}")
                    }
                }
                mediaRecorder = null

                // بازگرداندن preview
                createPreviewSession()

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

    }
}